<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Metrics Spreadsheet - Hello World</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }
        .metrics-table th,
        .metrics-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .metrics-table th {
            background-color: #2E7D32;
            color: white;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .metrics-table th:hover {
            background-color: #1B5E20;
        }
        .metrics-table th:focus {
            outline: 2px solid #FFC107;
            outline-offset: 2px;
        }
        .metrics-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .metrics-table tr:hover {
            background-color: #e8f5e8;
        }
        .sort-arrow {
            float: right;
            margin-left: 10px;
        }
        .file-info {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        .stat-card {
            background-color: #fff;
            border: 2px solid #2E7D32;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            text-align: center;
            min-width: 120px;
            flex: 1;
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #1B5E20;
            font-size: 24px;
        }
        .stat-card p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }
        .refresh-btn {
            background-color: #2E7D32;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .refresh-btn:hover {
            background-color: #1B5E20;
        }
        .refresh-btn:focus {
            outline: 2px solid #FFC107;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Code Metrics Spreadsheet</h1>
        
        <div class="file-info">
            <h3>Project: Hello World C Program</h3>
            <p><strong>File:</strong> hello.c</p>
            <p><strong>Last Analyzed:</strong> <span id="lastAnalyzed"></span></p>
            <button class="refresh-btn" onclick="analyzeCode()">üîÑ Refresh Metrics</button>
        </div>

        <div class="summary-stats" id="summaryStats">
            <!-- Summary statistics will be populated here -->
        </div>

        <table class="metrics-table" id="metricsTable" role="table" aria-label="Code metrics data">
            <thead>
                <tr role="row">
                    <th role="columnheader" tabindex="0" onclick="sortTable(0)" onkeydown="handleKeyDown(event, 0)" 
                        aria-sort="none" aria-label="Sort by Metric name">
                        Metric <span class="sort-arrow">‚ÜïÔ∏è</span>
                    </th>
                    <th role="columnheader" tabindex="0" onclick="sortTable(1)" onkeydown="handleKeyDown(event, 1)" 
                        aria-sort="none" aria-label="Sort by Value">
                        Value <span class="sort-arrow">‚ÜïÔ∏è</span>
                    </th>
                    <th role="columnheader" tabindex="0" onclick="sortTable(2)" onkeydown="handleKeyDown(event, 2)" 
                        aria-sort="none" aria-label="Sort by Category">
                        Category <span class="sort-arrow">‚ÜïÔ∏è</span>
                    </th>
                    <th role="columnheader" tabindex="0" onclick="sortTable(3)" onkeydown="handleKeyDown(event, 3)" 
                        aria-sort="none" aria-label="Sort by Description">
                        Description <span class="sort-arrow">‚ÜïÔ∏è</span>
                    </th>
                </tr>
            </thead>
            <tbody id="metricsBody">
                <!-- Metrics will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
        // Hello.c source code (embedded for analysis)
        const sourceCode = `#include <stdio.h>

// Voice-driven code editing simulation
// This demonstrates how voice commands could theoretically be processed
// For interactive demo, compile and run voice_demo.c

int main(void){
    int rc = 0;
    // Default behavior - maintain compatibility
    puts("Hello world!");
    printf("Exit code: %d\\n", rc);
    return rc;
}
`;

        let currentSort = { column: -1, ascending: true };
        let metricsData = [];

        function analyzeCode() {
            const lines = sourceCode.split('\n');
            const nonEmptyLines = lines.filter(line => line.trim() !== '');
            const commentLines = lines.filter(line => line.trim().startsWith('//') || line.trim().startsWith('/*') || line.trim().startsWith('*'));
            const codeLines = nonEmptyLines.filter(line => {
                const trimmed = line.trim();
                return trimmed !== '' && !trimmed.startsWith('//') && !trimmed.startsWith('/*') && !trimmed.startsWith('*');
            });

            // Calculate various metrics
            metricsData = [
                { metric: 'Total Lines', value: lines.length, category: 'Size', description: 'Total number of lines in the file' },
                { metric: 'Non-Empty Lines', value: nonEmptyLines.length, category: 'Size', description: 'Lines containing code or comments' },
                { metric: 'Code Lines', value: codeLines.length, category: 'Size', description: 'Lines containing actual code' },
                { metric: 'Blank Lines', value: lines.length - nonEmptyLines.length, category: 'Size', description: 'Empty or whitespace-only lines' },
                { metric: 'Comment Lines', value: commentLines.length, category: 'Documentation', description: 'Lines containing comments' },
                { metric: 'Total Characters', value: sourceCode.length, category: 'Size', description: 'Total character count including whitespace' },
                { metric: 'Characters (no spaces)', value: sourceCode.replace(/\s/g, '').length, category: 'Size', description: 'Character count excluding whitespace' },
                { metric: 'Word Count', value: sourceCode.split(/\s+/).filter(word => word.length > 0).length, category: 'Size', description: 'Total number of words' },
                { metric: 'Include Statements', value: countIncludes(), category: 'Dependencies', description: 'Number of #include statements' },
                { metric: 'Functions', value: countFunctions(), category: 'Structure', description: 'Number of function definitions' },
                { metric: 'Function Calls', value: countFunctionCalls(), category: 'Structure', description: 'Number of function calls' },
                { metric: 'Curly Braces', value: countOccurrences('{') + countOccurrences('}'), category: 'Structure', description: 'Total opening and closing braces' },
                { metric: 'Semicolons', value: countOccurrences(';'), category: 'Structure', description: 'Number of statement terminators' },
                { metric: 'String Literals', value: countStringLiterals(), category: 'Literals', description: 'Number of string literals' },
                { metric: 'Complexity Score', value: calculateComplexity(), category: 'Quality', description: 'Simple complexity metric (functions + conditions)' },
                { metric: 'Avg Line Length', value: Math.round(sourceCode.replace(/\n/g, '').length / nonEmptyLines.length), category: 'Quality', description: 'Average characters per non-empty line' }
            ];

            populateTable();
            populateSummary();
            updateLastAnalyzed();
        }

        function countIncludes() {
            return (sourceCode.match(/#\s*include/g) || []).length;
        }

        function countFunctions() {
            // Simple function counting - looks for patterns like "type name("
            return (sourceCode.match(/\b\w+\s+\w+\s*\(/g) || []).length;
        }

        function countFunctionCalls() {
            // Count function calls like "printf("
            return (sourceCode.match(/\w+\s*\(/g) || []).length;
        }

        function countOccurrences(char) {
            return (sourceCode.match(new RegExp('\\' + char, 'g')) || []).length;
        }

        function countStringLiterals() {
            return (sourceCode.match(/"[^"]*"/g) || []).length;
        }

        function calculateComplexity() {
            // Simple complexity: functions + conditions + loops
            const functions = countFunctions();
            const conditions = (sourceCode.match(/\b(if|else|switch|case)\b/g) || []).length;
            const loops = (sourceCode.match(/\b(for|while|do)\b/g) || []).length;
            return functions + conditions + loops;
        }

        function populateTable() {
            const tbody = document.getElementById('metricsBody');
            tbody.innerHTML = '';

            metricsData.forEach(metric => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = metric.metric;
                row.insertCell(1).textContent = metric.value;
                row.insertCell(2).textContent = metric.category;
                row.insertCell(3).textContent = metric.description;
            });
        }

        function populateSummary() {
            const summaryStats = document.getElementById('summaryStats');
            const totalLines = metricsData.find(m => m.metric === 'Total Lines').value;
            const codeLines = metricsData.find(m => m.metric === 'Code Lines').value;
            const functions = metricsData.find(m => m.metric === 'Functions').value;
            const complexity = metricsData.find(m => m.metric === 'Complexity Score').value;

            summaryStats.innerHTML = `
                <div class="stat-card">
                    <h3>${totalLines}</h3>
                    <p>Total Lines</p>
                </div>
                <div class="stat-card">
                    <h3>${codeLines}</h3>
                    <p>Code Lines</p>
                </div>
                <div class="stat-card">
                    <h3>${functions}</h3>
                    <p>Functions</p>
                </div>
                <div class="stat-card">
                    <h3>${complexity}</h3>
                    <p>Complexity</p>
                </div>
            `;
        }

        function updateLastAnalyzed() {
            document.getElementById('lastAnalyzed').textContent = new Date().toLocaleString();
        }

        function sortTable(columnIndex) {
            if (currentSort.column === columnIndex) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = columnIndex;
                currentSort.ascending = true;
            }

            metricsData.sort((a, b) => {
                let aVal, bVal;
                
                switch(columnIndex) {
                    case 0: aVal = a.metric; bVal = b.metric; break;
                    case 1: aVal = a.value; bVal = b.value; break;
                    case 2: aVal = a.category; bVal = b.category; break;
                    case 3: aVal = a.description; bVal = b.description; break;
                }

                // Handle numeric vs string comparison
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return currentSort.ascending ? aVal - bVal : bVal - aVal;
                } else {
                    const comparison = String(aVal).localeCompare(String(bVal));
                    return currentSort.ascending ? comparison : -comparison;
                }
            });

            populateTable();
            updateSortArrows();
        }

        function updateSortArrows() {
            const arrows = document.querySelectorAll('.sort-arrow');
            const headers = document.querySelectorAll('th[role="columnheader"]');
            arrows.forEach((arrow, index) => {
                if (index === currentSort.column) {
                    arrow.textContent = currentSort.ascending ? '‚Üë' : '‚Üì';
                    headers[index].setAttribute('aria-sort', currentSort.ascending ? 'ascending' : 'descending');
                } else {
                    arrow.textContent = '‚ÜïÔ∏è';
                    headers[index].setAttribute('aria-sort', 'none');
                }
            });
        }

        function handleKeyDown(event, columnIndex) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                sortTable(columnIndex);
            }
        }

        // Test function to verify metrics calculation
        function runSelfTest() {
            console.log('üß™ Running self-test...');
            const testResults = {};
            
            // Test with known input (current hello.c)
            const expectedMetrics = {
                'Total Lines': 14,
                'Code Lines': 7,
                'Functions': 2,
                'Include Statements': 1,
                'String Literals': 2,
                'Semicolons': 4
            };
            
            analyzeCode();
            
            let allTestsPassed = true;
            for (const [metricName, expectedValue] of Object.entries(expectedMetrics)) {
                const actualMetric = metricsData.find(m => m.metric === metricName);
                if (!actualMetric) {
                    console.error(`‚ùå Test failed: Metric "${metricName}" not found`);
                    allTestsPassed = false;
                    continue;
                }
                
                if (actualMetric.value !== expectedValue) {
                    console.error(`‚ùå Test failed: ${metricName} expected ${expectedValue}, got ${actualMetric.value}`);
                    allTestsPassed = false;
                } else {
                    console.log(`‚úÖ ${metricName}: ${actualMetric.value}`);
                }
                testResults[metricName] = actualMetric.value;
            }
            
            if (allTestsPassed) {
                console.log('üéâ All self-tests passed!');
            } else {
                console.error('‚ùå Some self-tests failed');
            }
            
            return testResults;
        }

        // Initialize the analysis when page loads and run self-test
        document.addEventListener('DOMContentLoaded', function() {
            analyzeCode();
            // Run self-test in development mode (when console is available)
            if (typeof console !== 'undefined') {
                setTimeout(() => runSelfTest(), 100);
            }
        });
    </script>
</body>
</html>